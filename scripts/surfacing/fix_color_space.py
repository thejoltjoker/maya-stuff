#!/usr/bin/env python3
"""fix_color_space.py
Description of fix_color_space.py.
"""
import logging
from maya import cmds

logging.basicConfig(level=logging.DEBUG, format='# %(message)s')
logger = logging.getLogger()
IGNORE = ['initialShadingGroup', 'initialShadingGroup', 'initialParticleSE', 'lambert1']
COLOR_SPACES = {
    'coat_bump_input': 'Raw',
    'coat_color': 'sRGB',
    'coat_direct': 'Raw',
    'coat_indirect': 'Raw',
    'coat_ior': 'Raw',
    'coat_ior3': 'Raw',
    'coat_reflectivity': 'Raw',
    'coat_roughness': 'Raw',
    'coat_transmittance': 'sRGB',
    'coat_weight': 'Raw',
    'diffuse_direct': 'Raw',
    'diffuse_indirect': 'Raw',
    'diffuse_roughness': 'Raw',
    'diffuse_weight': 'Raw',
    'emission_color': 'sRGB',
    'emission_weight': 'Raw',
    'ms_color0': 'sRGB',
    'ms_color1': 'sRGB',
    'ms_color2': 'sRGB',
    'ms_radius0': 'Raw',
    'ms_radius1': 'Raw',
    'ms_radius2': 'Raw',
    'ms_radius_scale': 'Raw',
    'ms_weight0': 'Raw',
    'ms_weight1': 'Raw',
    'ms_weight2': 'Raw',
    'opacity_color': 'Raw',
    'overall_color': 'sRGB',
    'refl_aniso': 'Raw',
    'refl_color': 'sRGB',
    'refl_cutoff': 'Raw',
    'refl_direct': 'Raw',
    'refl_edge_tint': 'Raw',
    'refl_indirect': 'Raw',
    'refl_ior': 'Raw',
    'refl_ior3': 'Raw',
    'refl_k3': 'Raw',
    'refl_reflectivity': 'Raw',
    'refl_weight': 'Raw',
    'refr_abbe': 'Raw',
    'refr_absorption_scale': 'Raw',
    'refr_color': 'sRGB',
    'refr_cutoff': 'Raw',
    'refr_ior': 'Raw',
    'refr_roughness': 'Raw',
    'refr_transmittance': 'sRGB',
    'refr_weight': 'Raw',
    'shadow_opacity': 'Raw',
    'sheen_color': 'sRGB',
    'sheen_direct': 'Raw',
    'sheen_indirect': 'Raw',
    'sheen_roughness': 'Raw',
    'sheen_weight': 'Raw',
    'ss_amount': 'Raw',
    'ss_extinction_coeff': 'Raw',
    'ss_extinction_scale': 'Raw',
    'ss_phase': 'Raw',
    'ss_scatter_coeff': 'sRGB',
    'transl_color': 'Raw',
    'transl_weight': 'Raw',
    'diffuse_color': 'sRGB',
    'refl_roughness': 'Raw',
    'refl_aniso_rotation': 'Raw',
    'bump_input': 'Raw',
    'refl_metalness': 'Raw'
}


def get_inputs(node):
    """Get all input connections for a node

    Args:
        node: input node

    Returns:
        dict: input connections and nodes
    """
    inputs = {node: {}}
    if not node in IGNORE:
        # logger.info(f'Connections to {node}')
        conn = cmds.listConnections(node, s=True, d=False, c=True)
        if conn:
            for i in range(len(conn)):
                if i % 2 == 0:
                    conn_in = conn[i].split('.')[-1]
                    conn_out = conn[i + 1]
                    inputs[node]['type'] = cmds.nodeType(node)

                    if not inputs[node].get('connections'):
                        inputs[node]['connections'] = {}
                    if not conn_in.endswith('.message'):
                        # logger.info(f'{conn_in}: {conn_out}')
                        inputs[node]['connections'][conn_in] = get_inputs(conn_out)
                    else:
                        inputs[node]['connections'][conn_in] = conn_out

    return inputs


def get_colorspace(node):
    """Get the colorspace of a node

    Args:
        node: file node

    Returns:
        str: Colorspace
    """
    has_colorspace = cmds.attributeQuery('colorSpace', node=node, ex=True)
    attrib = node + '.colorSpace'

    if has_colorspace:
        return cmds.getAttr(attrib)
    return ''


def change_colorspace(node, color_space):
    """Change the colorspace of a node

    Args:
        node: file node
        color_space: chosen color space

    Returns:

    """
    has_colorspace = cmds.attributeQuery('colorSpace', node=node, ex=True)
    attrib = node + '.colorSpace'

    if has_colorspace:
        cmds.setAttr(attrib, color_space, type='string')

    return cmds.getAttr(attrib)


def process_tree(tree, color_space='Raw', dryrun=False):
    """Process a dict of nodes and connections

    Args:
        dryrun: Set to True to not change anything
        tree: dict with nodes and connections. Generated by get_inputs()
        color_space: The chosen color space for the node
    """
    nodes = []
    node = list(tree)[0]
    node_type = tree[node].get('type')

    # Check if the key has a node type or it's just a connection
    if node_type:
        if node_type == 'file':

            if not dryrun:
                logger.info(f'Changing {node} input color space to {color_space}')
                change_colorspace(node, color_space)
            else:
                logger.info(f'Input color space for {node} is {get_colorspace(node)}, should be {color_space}')
            nodes.append(node)
        for k, v in tree[node].get('connections', {}).items():
            nodes.extend(process_tree(v, color_space=color_space, dryrun=dryrun))
    return nodes


def check():
    """docstring for main"""
    all_materials = cmds.ls(mat=True)

    for material in all_materials:
        logger.info(f'Checking inputs for {material}')
        inputs = get_inputs(material)

        for k, v in inputs[material].get('connections', {}).items():
            # Determine color space
            clr_space = COLOR_SPACES.get(k, 'Raw')
            logger.info(f'Looking up file input color spaces for {k}, should be {clr_space}')

            # Process connections
            process_tree(v, clr_space, dryrun=True)


def fix():
    """docstring for main"""
    all_materials = cmds.ls(mat=True)

    for material in all_materials:
        logger.info(f'Processing inputs for {material}')
        inputs = get_inputs(material)

        for k, v in inputs[material].get('connections', {}).items():
            # Determine color space
            clr_space = COLOR_SPACES.get(k, 'Raw')
            logger.info(f'Changing all file input color spaces for {k} to {clr_space}')

            # Process connections
            process_tree(v, clr_space, dryrun=False)


def main():
    fix()


if __name__ == '__main__':
    main()
